# Unicode


## 概念
### ASCII 码
> 一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从`0000 0000 ~ 1111 1111` `0x00 ~ 0xFF`
> 
> ASCII 码一共规定了128个字符的编码，只占用了一个字节的后面7位，最前面的一位统一规定为0。


###  Unicode 编码
> Unicode 标准为世界上几乎所有的书写系统里所使用的每一个字符或符号定义了一个唯一的数字。
> 
> Unicode 编码是被设计为 16 位的，提供了 65,536 个字符的空间。
> 
> 后来，考虑到要编码历史上的文字以及一些很少使用的日本汉字和中国汉字，**Unicode 编码扩展到了 21 位（从 `U+0000 ~ U+10FFFF`）**。
> 
> **Unicode 不是 16 位的编码！它是 21 位的。**这 21 位提供了 1,114,112 个码点，其中，只有大概 10% 正在使用，所以还有相当大的扩充空间。
> 
> Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。

### 码点（code points）
> 以 `U+xxxx` 这样的格式写成，格式里的 `xxxx` 代表四到六个十六进制的数。比如，`U+0041`（十进制是 65）

### 平面（plane）
> 编码空间被分成 17 个平面（plane），每个平面有 65,536 个字符。0 号平面叫做「基本多文种平面」（Basic Multilingual Plane, BMP），涵盖了几乎所有你能遇到的字符，除了 emoji。其它平面叫做补充平面，大多是空的。

### 标准等价（canonically equivalent）
> 两种形式并不相等（因为两种形式包含不同的码点），但有着相同的外观和意义。
> 
> 要永久保存一个字符串，一般情况下不应该用相容等价的方式去将它正规化，因为这样会改变文本的含义

### 相容等价（compatibility equivalence）
> 相容的序列代表着相同的字符，但有着不同的外观和表现。例子包括很多被用作数学和技术符号的希腊字母，还有，尽管已经有了从 `U+2160` 到 `U+2183` 这个范围里的标准拉丁字母，罗马数字也被单独编入 Unicode。


### 正规化（normalization）算法
> 正规化一个字符串的意思是：为了能使它与另一个正规化了的字符串进行**二进制比较（binary-compare）**，将其转化成有且仅有的唯一一个表示形式，这个形式由等价字符的序列组成。

Unicode 标准里包含了四个正规形式，分别是 C、D、KD 和 KC。它们可以放入一个 2*2 的矩阵里（下面还列举出了 NSString 提供的对应方法）：

Unicode 正规形式（NF）	| 字符形式 合成形式（é）	| 分解形式（e + ´）
--- | --- | ---
--- | C | D
标准等价 | precomposed​String​With​Canonical​Mapping | decomposed​String​With​Canonical​Mapping
 | KC | KD
相容等价 | 	precomposed​String​With​Compatibility​Mapping | decomposed​String​With​Compatibility​Mapping

仅仅为了比较的话，先把字符串正规化成分解形式（D）还是合成形式（C）并不重要。但 C 形式的算法包含两个步骤：先分解字符再重新组合起来，因此 D 形式要更快一些。

### Unicode 转换格式
> 字符和码点之间的映射只完成了一半工作，还需要定义另一种编码来确定码点在内存和硬盘中要如何表示。Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。Unicode 标准为此定义了几种映射，叫做「Unicode 转换格式」（Unicode Transformation Formats，简称 UTF）

### UTF-32
> 最清楚明了的一个 UTF 就是 UTF-32：它在每个码点上使用整 32 位。32 大于 21，因此每一个 UTF-32 值都可以直接表示对应的码点。尽管简单，UTF-32却几乎从来不在实际中使用，因为每个字符占用 4 字节太浪费空间了。

### UTF-16 以及「代理对」（Surrogate Pairs）的概念
UTF-16 本身是一种长度可变的编码。

> 基本多文种平面（BMP）中的每一个码点都直接与一个码元相映射。鉴于 BMP 几乎囊括了所有常见字符，UTF-16 一般只需要 UTF-32 一半的空间。其它平面里很少使用的码点都是用两个 16 位的码元来编码的，这两个合起来表示一个码点的码元就叫做代理对（surrogate pair）。
> 
> **Unicode 标准限制了 U+D800 到 U+DFFF 范围内的码点用于 UTF-16**，这个范围内的码点值不能分配给任何字符。当程序在一个 UTF-16 编码的字符串里发现在这个范围内的序列时，就能立刻知道这是某个代理对的一部分。
> 
> 和所有多字节长度的编码系统一样，UTF-16（以及 UTF-32）还得解决字节顺序的问题。在内存里存储字符串时，大多数实现方式自然都采用自己运行平台的 CPU 的字节序（endianness）；而在硬盘里存储或者通过网络传输字符串时，UTF-16 允许在字符串的开头插入一个**「字节顺序标记」（Byte Order Mask，简称 BOM）**。字节顺序标记是一个值为 `U+FEFF` 的码元，通过检查文件的头两个字节，解码器就可以识别出其字节顺序。字节顺序标记不是必须的，Unicode 标准把高字节顺序（big-endian byte order）定为默认情况。UTF-16 需要指明字节顺序，这也是为什么 UTF-16 在文件格式和网络传输方面不受欢迎的一个原因，不过微软和苹果都在自己的操作系统内部使用它。

### UTF-8
UTF-8 是一种长度可变的编码，使用1~4个字节来编码一个码点。

1. 对于单字节的符号  
    字节的第一位设为0，后面7位为这个符号的 Unicode 码 从 0 到 127 (`0000 0000 ~ 0111 1111` `0x0000 ~ 0x007F` `U+0000 ~ U+007F`)。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。
  
2. 对于n字节的符号（n > 1）  
    第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。

下表总结了编码规则，字母x表示可用编码的位。


Unicode符号范围     |        UTF-8编码方式
---|---
0000 0000 - 0000 007F | 0xxxxxxx
0000 0080 - 0000 07FF | 110xxxxx 10xxxxxx
0000 0800 - 0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000 - 0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

`严`的 Unicode 是`0x4E25`（`100111000100101`），根据上表，可以发现`0x4E25`处在第三行的范围内（`0000 0800 - 0000 FFFF`），因此严的 UTF-8 编码需要三个字节，即格式是`1110xxxx 10xxxxxx 10xxxxxx`。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的`x`，多出的位补`0`。这样就得到了，严的 UTF-8 编码是`11100100 10111000 10100101`，转换成十六进制就是`0xE4B8A5`。

```
11100100 10111000 10100101
1110xxxx 10xxxxxx 10xxxxxx
     100   111000 10100101
     10011100010100101
     0xE4B8A5
```


> 为什么后面字节的前两位一律设为10？  
> 后面字节的前两位一律设为10(10000000也就是80)是因为必须要大于7F才和ASCII码分开
> 
> UTF-8 是基于 8 位的码元的，因此它并不需要关心字节顺序（不过仍有一些程序会在 UTF-8 文件里加上多余的 BOM）。
> 
> 有效率的空间使用（仅就西方语言来讲），以及不需要操心字节顺序问题使得 UTF-8 成为存储和交流 Unicode 文本方面的最佳编码。它也已经是文件格式、网络协议以及 Web API 领域里事实上的标准了。

##参考
* [NSString 与 Unicode](https://objccn.io/issue-9-1/)
* [字符编码笔记：ASCII，Unicode 和 UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)
