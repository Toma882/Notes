那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？

这里我们可以避开完整的技术细节，基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。

因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。

编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用`var`还是`new`声明变量的方式决定的。

```go
var global *int

# f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，
# 虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了
func f() {
    var x int
    x = 1
    global = &x
}

# 当g函数返回时，变量*y将是不可达的，也就是说可以马上被回收的
func g() {
    y := new(int)
    *y = 1
}
```