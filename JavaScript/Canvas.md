# Canvas

## 计算与渲染
把动画的一帧渲染出来，需要经过以下步骤：

* 计算：处理游戏逻辑，计算每个对象的状态，不涉及 DOM 操作（当然也包含对 Canvas 上下文的操作）。
* 渲染：真正把对象绘制出来。 
    * JavaScript 调用 DOM API（包括 Canvas API）以进行渲染。 
    * 浏览器（通常是另一个渲染线程）把渲染后的结果呈现在屏幕上的过程。

通常情况下，渲染比计算的开销大很多（3~4 个量级）。动画流畅的真实前提是，以上所有工作都在 16ms（假设一秒60帧，那么一帧16ms） 中完成，所以 JavaScript 层面消耗的时间最好控制在 10ms 以内。

## 如何优化渲染的性能总体思路


* 在每一帧中，尽可能减少调用渲染相关 API 的次数（通常是以计算的复杂化为代价的）。
* 在每一帧中，尽可能调用那些渲染开销较低的 API。
* 在每一帧中，尽可能以「导致渲染开销较低」的方式调用渲染相关 API。

## Canvas 上下文是状态机

Canvas API 都在其上下文对象 context 上调用。

```js
var context = canvasElement.getContext('2d');
```

```js
context.lineWidth = 5;
context.strokeColor = 'rgba(1, 0.5, 0.5, 1)';
context.strokeRect(100, 100, 80, 80);
```

Canvas 上下文不是一个普通的对象，当你调用了 `context.lineWidth = 5` 时，浏览器会需要立刻地做一些事情，这样你下次调用诸如 `stroke` 或 `strokeRect` 等 API 时，画出来的线就正好是 5 个像素宽了（不难想象，这也是一种优化，否则，这些事情就要等到下次 `stroke` 之前做，更加会影响性能）。

## Canvas 处理非法输入

我尝试执行以下赋值操作 10^6 次，得到的结果是：对一个普通对象的属性赋值只消耗了 3ms，而对 context 的属性赋值则消耗了 40ms。值得注意的是，如果你赋的值是非法的，浏览器还需要一些额外时间来处理非法输入，正如第三/四种情形所示，消耗了 140ms 甚至更多。

```js
somePlainObject.lineWidth = 5;  // 3ms (10^6 times)
context.lineWidth = 5;  // 40ms
context.lineWidth = 'Hello World!'; // 140ms
context.lineWidth = {}; // 600ms
```

## 分层 Canvas

分层 Canvas 的出发点是，动画中的每种元素（层），对渲染和动画的要求是不一样的。对很多游戏而言，主要角色变化的频率和幅度是很大的（他们通常都是走来走去，打打杀杀的），而背景变化的频率或幅度则相对较小（基本不变，或者缓慢变化，或者仅在某些时机变化）。很明显，我们需要很频繁地更新和重绘人物，但是对于背景，我们也许只需要绘制一次，也许只需要每隔 200ms 才重绘一次，绝对没有必要每 16ms 就重绘一次。对于 Canvas 而言，能够在每层 Canvas 上保持不同的重绘频率已经是最大的好处了。然而，分层思想所解决的问题远不止如此。

使用上，分层 Canvas 也很简单。我们需要做的，仅仅是生成多个 Canvas 实例，把它们重叠放置，每个 Canvas 使用不同的 z-index 来定义堆叠的次序。然后仅在需要绘制该层的时候（也许是「永不」）进行重绘。

```js
var contextBackground = canvasBackground.getContext('2d');
var contextForeground = canvasForeground.getContext('2d'); 
function render()
{
    drawForeground(contextForeground);
    if(needUpdateBackground)
    {
        drawBackground(contextBackground);
    }
    requestAnimationFrame(render);
}
```

## Canvas 裁剪
绘制同样的一块区域，如果数据源是尺寸相仿的一张图片，那么性能会比较好，而如果数据源是一张大图上的一部分，性能就会比较差，因为每一次绘制还包含了裁剪工作。我们可以先把待绘制的区域裁剪好，保存起来，这样每次绘制时就能轻松很多。

## 离屏 Canvas

Canvas 只是游戏世界的一个「窗口」，如果我们在每一帧中，都把整个世界全部画出来，势必就会有很多东西画到 Canvas 外面去了，同样调用了绘制 API，但是并没有任何效果。判断对象是否在 Canvas 中会有额外的计算开销（比如需要对游戏角色的全局模型矩阵求逆，以分解出对象的世界坐标，这并不是一笔特别廉价的开销），而且也会增加代码的复杂程度，所以关键是，是否值得。

绘制一张 320x180 的图片 10^4 次，每次都绘制在 Canvas 内部时，消耗了 40ms，而每次都绘制在 Canvas 外时，仅消耗了 8ms。考虑到计算的开销与绘制的开销相差 2~3 个数量级，我认为通过计算来过滤掉哪些画布外的对象，仍然是很有必要的。

所以，调用canvas的API很消耗性能，当我们要绘制一些重复的画面数据时，妥善利用离屏canvas对性能方面有很大的提升

## 避免「阻塞」

所谓「阻塞」，可以理解为不间断运行时间超过 16ms 的 JavaScript 代码，以及「导致浏览器花费超过 16ms 时间进行处理」的 JavaScript 代码。

偶尔的且较小的阻塞是可以接收的，频繁或较大的阻塞是不可以接受的。也就是说，我们需要解决两种阻塞：

* 频繁（通常较小）的阻塞。其原因主要是过高的渲染性能开销，在每一帧中做的事情太多
* 较大（虽然偶尔发生）的阻塞。其原因主要是运行复杂算法、大规模的 DOM 操作等等

对前者，我们应当仔细地优化代码，有时不得不降低动画的复杂（炫酷）程度，本文前几节中的优化方案，解决的就是这个问题。
而对于后者，主要有以下两种优化的策略。

* 使用 Web Worker，在另一个线程里进行计算。
* 将任务拆分为多个较小的任务，插在多帧中进行。

Web Worker 是好东西，性能很好，兼容性也不错。浏览器用另一个线程来运行 Worker 中的 JavaScript 代码，完全不会阻碍主线程的运行。动画（尤其是游戏）中难免会有一些时间复杂度比较高的算法（寻路等？），用 Web Worker 来运行再合适不过了。

然而，Web Worker 无法对 DOM 进行操作。所以，有些时候，我们也使用另一种策略来优化性能，那就是将任务拆分成多个较小的任务，依次插入每一帧中去完成。虽然这样做几乎肯定会使执行任务的总时间变长，但至少动画不会卡住了。




有一个相同的前提，即任务是异步的。也就是说，当你决定开始执行一项任务的时候，你并不需要立刻（在下一帧）知道结果。
比如，即使战略游戏中用户的某个操作触发了寻路算法，你完全可以等待几帧（用户完全感知不到）再开始移动游戏角色。
另外，将任务拆分以优化性能，会带来显著的代码复杂度的增加，以及额外的开销。有时候，我觉得也许可以考虑优先砍一砍需求。




## 小结

* 将渲染阶段的开销转嫁到计算阶段之上。
* 使用多个分层的 Canvas 绘制复杂场景。
* 不要频繁设置绘图上下文的 font 属性。
* 不在动画中使用 putImageData 方法。
* 通过计算和判断，避免无谓的绘制操作。
* 将固定的内容预先绘制在离屏 Canvas 上以提高性能。
* 使用 Worker 和拆分任务的方法避免复杂算法阻塞动画运行


## 参考
[canvas---性能](https://juejin.im/post/5b4076215188251aa82904bd)

